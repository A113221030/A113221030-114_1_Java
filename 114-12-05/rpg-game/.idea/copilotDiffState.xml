<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Defendable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Defendable.java" />
              <option name="originalContent" value="public class Defendable {/**&#10; * Defendable - 可防禦介面&#10; *&#10; * 為什麼需要介面？&#10; * 1. Java 只支援單一繼承，但可以實作多個介面&#10; * 2. 介面描述「能做什麼」（can-do），抽象類別描述「是什麼」（is-a）&#10; * 3. 不同類型的角色都可能有防禦能力&#10; *&#10; * 誰需要實作這個介面？&#10; * - ShieldSwordsMan（持盾劍士）：用盾牌防禦&#10; * - 未來的角色如 Paladin（聖騎士）：用聖光防禦&#10; *&#10; * 介面 vs 抽象類別：&#10; * - 介面：定義「能力」，可以實作多個&#10; * - 抽象類別：定義「本質」，只能繼承一個&#10; */&#10;public interface Defendable {&#10;&#10;    /**&#10;     * 執行防禦動作（抽象方法）&#10;     * 實作這個介面的類別必須提供防禦的具體實作&#10;     */&#10;    void defend();&#10;&#10;    /**&#10;     * 取得防禦力（抽象方法）&#10;     * @return 防禦力數值&#10;     */&#10;    int getDefenseCapacity();&#10;&#10;    /**&#10;     * 檢查是否可以防禦（預設方法）&#10;     * 這是介面的預設方法（default method，Java 8+）&#10;     * 子類別可以選擇性覆寫&#10;     *&#10;     * @return true 如果可以防禦&#10;     */&#10;    default boolean canDefend() {&#10;        return getDefenseCapacity() &gt; 0;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Defendable - 可防禦介面&#10; *&#10; * 為什麼需要介面？&#10; * 1. Java 只支援單一繼承，但可以實作多個介面&#10; * 2. 介面描述「能做什麼」（can-do），抽象類別描述「是什麼」（is-a）&#10; * 3. 不同類型的角色都可能有防禦能力&#10; *&#10; * 誰需要實作這個介面？&#10; * - ShieldSwordsMan（持盾劍士）：用盾牌防禦&#10; * - 未來的角色如 Paladin（聖騎士）：用聖光防禦&#10; *&#10; * 介面 vs 抽象類別：&#10; * - 介面：定義「能力」，可以實作多個&#10; * - 抽象類別：定義「本質」，只能繼承一個&#10; */&#10;public interface Defendable {&#10;&#10;    /**&#10;     * 執行防禦動作（抽象方法）&#10;     * 實作這個介面的類別必須提供防禦的具體實作&#10;     */&#10;    void defend();&#10;&#10;    /**&#10;     * 取得防禦力（抽象方法）&#10;     * @return 防禦力數值&#10;     */&#10;    int getDefenseCapacity();&#10;&#10;    /**&#10;     * 檢查是否可以防禦（預設方法）&#10;     * 這是介面的預設方法（default method，Java 8+）&#10;     * 子類別可以選擇性覆寫&#10;     *&#10;     * @return true 如果可以防禦&#10;     */&#10;    default boolean canDefend() {&#10;        return getDefenseCapacity() &gt; 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Healable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Healable.java" />
              <option name="originalContent" value="public class Healable {/**&#10; * Healable - 可治療介面&#10; *&#10; * 為什麼需要介面？&#10; * 1. 治療能力不限於特定類型的角色&#10; * 2. 魔法師、牧師、聖騎士都可能有治療能力&#10; * 3. 使用介面可以讓不同類別共享治療能力&#10; *&#10; * 誰需要實作這個介面？&#10; * - Magician（魔法師）：魔法治療&#10; * - Priest（牧師）：神聖治療&#10; * - 未來的 Paladin（聖騎士）：聖光治療&#10; *&#10; * 介面的好處：&#10; * - 靈活性：任何類別都可以實作&#10; * - 多重實作：一個類別可以同時實作 Healable 和 Defendable&#10; * - 清晰的契約：明確定義「可治療」的行為&#10; */&#10;public interface Healable {&#10;&#10;    /**&#10;     * 治療目標角色（抽象方法）&#10;     * @param target 被治療的角色&#10;     */&#10;    void heal(Role target);&#10;&#10;    /**&#10;     * 取得治療力（抽象方法）&#10;     * @return 治療力數值&#10;     */&#10;    int getHealPower();&#10;&#10;    /**&#10;     * 檢查是否可以治療（預設方法）&#10;     * 子類別可以選擇性覆寫&#10;     *&#10;     * @return true 如果可以治療&#10;     */&#10;    default boolean canHeal() {&#10;        return getHealPower() &gt; 0;&#10;    }&#10;&#10;    /**&#10;     * 顯示治療資訊（預設方法）&#10;     * 提供一個基本的治療資訊顯示&#10;     * 子類別可以選擇性覆寫&#10;     */&#10;    default void showHealInfo() {&#10;        System.out.println(&quot; 治療力：&quot; + getHealPower() + &quot; 點&quot;);&#10;    }&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Healable - 可治療介面&#10; *&#10; * 為什麼需要介面？&#10; * 1. 治療能力不限於特定類型的角色&#10; * 2. 魔法師、牧師、聖騎士都可能有治療能力&#10; * 3. 使用介面可以讓不同類別共享治療能力&#10; *&#10; * 誰需要實作這個介面？&#10; * - Magician（魔法師）：魔法治療&#10; * - Priest（牧師）：神聖治療&#10; * - 未來的 Paladin（聖騎士）：聖光治療&#10; *&#10; * 介面的好處：&#10; * - 靈活性：任何類別都可以實作&#10; * - 多重實作：一個類別可以同時實作 Healable 和 Defendable&#10; * - 清晰的契約：明確定義「可治療」的行為&#10; */&#10;public interface Healable {&#10;&#10;    /**&#10;     * 治療目標角色（抽象方法）&#10;     * @param target 被治療的角色&#10;     */&#10;    void heal(Role target);&#10;&#10;    /**&#10;     * 取得治療力（抽象方法）&#10;     * @return 治療力數值&#10;     */&#10;    int getHealPower();&#10;&#10;    /**&#10;     * 檢查是否可以治療（預設方法）&#10;     * 子類別可以選擇性覆寫&#10;     *&#10;     * @return true 如果可以治療&#10;     */&#10;    default boolean canHeal() {&#10;        return getHealPower() &gt; 0;&#10;    }&#10;&#10;    /**&#10;     * 顯示治療資訊（預設方法）&#10;     * 提供一個基本的治療資訊顯示&#10;     * 子類別可以選擇性覆寫&#10;     */&#10;    default void showHealInfo() {&#10;        System.out.println(&quot; 治療力：&quot; + getHealPower() + &quot; 點&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Role.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Role.java" />
              <option name="originalContent" value="// 第三階段和第四階段完全相同&#10;public abstract class Role {&#10;    private String name;&#10;    private int health;&#10;    private int attackPower;&#10;&#10;    public Role(String name, int health, int attackPower) {&#10;        this.name = name;&#10;        this.health = health;&#10;        this.attackPower = attackPower;&#10;    }&#10;&#10;    // getter/setter 方法&#10;    public String getName() { return name; }&#10;    public int getHealth() { return health; }&#10;    public int getAttackPower() { return attackPower; }&#10;    public void setHealth(int health) { this.health = health; }&#10;    public boolean isAlive() { return health &gt; 0; }&#10;&#10;    // 具體方法&#10;    public void takeDamage(int damage) {&#10;        this.health -= damage;&#10;        System.out.println(&quot; &quot; + name + &quot; 受到 &quot; + damage + &quot; 點傷害！目前生命值：&quot; + health);&#10;        if (!isAlive()) {&#10;            onDeath();&#10;        }&#10;    }&#10;&#10;    // 抽象方法&#10;    public abstract void attack(Role opponent);&#10;    public abstract void showSpecialSkill();&#10;    public abstract void onDeath();&#10;    public abstract void prepareBattle();&#10;    public abstract void afterBattle();&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;角色名稱: &quot; + name + &quot;, 生命值: &quot; + health;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// 第三階段和第四階段完全相同&#10;public abstract class Role {&#10;    private String name;&#10;    private int health;&#10;    private int maxHealth; // 新增：儲存最大生命值（初始化為建構子傳入的 health）&#10;    private int attackPower;&#10;&#10;    public Role(String name, int health, int attackPower) {&#10;        this.name = name;&#10;        this.health = health;&#10;        this.attackPower = attackPower;&#10;        this.maxHealth = health; // 初始化最大生命值&#10;    }&#10;&#10;    // getter/setter 方法&#10;    public String getName() { return name; }&#10;    public int getHealth() { return health; }&#10;    public int getMaxHealth() { return maxHealth; } // 新增取得最大生命值&#10;    public int getAttackPower() { return attackPower; }&#10;    public void setHealth(int health) { this.health = health; }&#10;    public boolean isAlive() { return health &gt; 0; }&#10;&#10;    // 具體方法&#10;    public void takeDamage(int damage) {&#10;        this.health -= damage;&#10;        System.out.println(&quot; &quot; + name + &quot; 受到 &quot; + damage + &quot; 點傷害！目前生命值：&quot; + health);&#10;        if (!isAlive()) {&#10;            onDeath();&#10;        }&#10;    }&#10;&#10;    // 抽象方法&#10;    public abstract void attack(Role opponent);&#10;    public abstract void showSpecialSkill();&#10;    public abstract void onDeath();&#10;    public abstract void prepareBattle();&#10;    public abstract void afterBattle();&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;角色名稱: &quot; + name + &quot;, 生命值: &quot; + health;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>